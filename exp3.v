
//=======================================================
//  This code is generated by Terasic System Builder
//=======================================================

module exp3(

	//////////// CLOCK //////////
	CLOCK_50,
	CLOCK2_50,
	CLOCK3_50,

	//////////// LED //////////
	LEDG,
	LEDR,

	//////////// KEY //////////
	KEY,

	//////////// SW //////////
	SW,

	//////////// SEG7 //////////
	HEX0,
	HEX1,
	HEX2,
	HEX3,
	HEX4,
	HEX5,
	HEX6,
	HEX7,

	//////////// LCD //////////
	LCD_BLON,
	LCD_DATA,
	LCD_EN,
	LCD_ON,
	LCD_RS,
	LCD_RW,

	//////////// PS2 for Keyboard and Mouse //////////
	PS2_CLK,
	PS2_CLK2,
	PS2_DAT,
	PS2_DAT2,

	//////////// VGA //////////
	VGA_B,
	VGA_BLANK_N,
	VGA_CLK,
	VGA_G,
	VGA_HS,
	VGA_R,
	VGA_SYNC_N,
	VGA_VS,

	//////////// Audio //////////
	AUD_ADCDAT,
	AUD_ADCLRCK,
	AUD_BCLK,
	AUD_DACDAT,
	AUD_DACLRCK,
	AUD_XCK,

	//////////// I2C for EEPROM //////////
	EEP_I2C_SCLK,
	EEP_I2C_SDAT,

	//////////// I2C for Audio HSMC  //////////
	I2C_SCLK,
	I2C_SDAT,

	//////////// USB 2.0 OTG //////////
	OTG_ADDR,
	OTG_CS_N,
	OTG_DACK_N,
	OTG_DATA,
	OTG_DREQ,
	OTG_FSPEED,
	OTG_INT,
	OTG_LSPEED,
	OTG_RD_N,
	OTG_RST_N,
	OTG_WE_N,

	//////////// IR Receiver //////////
	IRDA_RXD,

	//////////// SDRAM //////////
	DRAM_ADDR,
	DRAM_BA,
	DRAM_CAS_N,
	DRAM_CKE,
	DRAM_CLK,
	DRAM_CS_N,
	DRAM_DQ,
	DRAM_DQM,
	DRAM_RAS_N,
	DRAM_WE_N,

	//////////// SRAM //////////
	SRAM_ADDR,
	SRAM_CE_N,
	SRAM_DQ,
	SRAM_LB_N,
	SRAM_OE_N,
	SRAM_UB_N,
	SRAM_WE_N,

	//////////// Flash //////////
	FL_ADDR,
	FL_CE_N,
	FL_DQ,
	FL_OE_N,
	FL_RST_N,
	FL_RY,
	FL_WE_N,
	FL_WP_N,

	//////////// GPIO, GPIO connect to GPIO Default //////////
	GPIO,

	//////////// HSMC, HSMC connect to HTG - HSMC to PIO Adaptor //////////
	HSMC_CLKIN_0,
	HSMC_CLKIN_n,
	HSMC_CLKIN_p,
	HSMC_CLKOUT_0,
	HSMC_CLKOUT_n,
	HSMC_CLKOUT_p,
	HSMC_D,
	HSMC_RX_n,
	HSMC_RX_p,
	HSMC_TX_n,
	HSMC_TX_p 
);

//=======================================================
//  PARAMETER declarations
//=======================================================


//=======================================================
//  PORT declarations
//=======================================================

//////////// CLOCK //////////
input 		          		CLOCK_50;
input 		          		CLOCK2_50;
input 		          		CLOCK3_50;

//////////// LED //////////
output		     [8:0]		LEDG;
output		    [17:0]		LEDR;

//////////// KEY //////////
input 		     [3:0]		KEY;

//////////// SW //////////
input 		    [17:0]		SW;

//////////// SEG7 //////////
output		     [6:0]		HEX0;
output		     [6:0]		HEX1;
output		     [6:0]		HEX2;
output		     [6:0]		HEX3;
output		     [6:0]		HEX4;
output		     [6:0]		HEX5;
output		     [6:0]		HEX6;
output		     [6:0]		HEX7;

//////////// LCD //////////
output		          		LCD_BLON;
inout 		     [7:0]		LCD_DATA;
output		          		LCD_EN;
output		          		LCD_ON;
output		          		LCD_RS;
output		          		LCD_RW;

//////////// PS2 for Keyboard and Mouse //////////
inout 		          		PS2_CLK;
inout 		          		PS2_CLK2;
inout 		          		PS2_DAT;
inout 		          		PS2_DAT2;

//////////// VGA //////////
output		     [7:0]		VGA_B;
output		          		VGA_BLANK_N;
output		          		VGA_CLK;
output		     [7:0]		VGA_G;
output		          		VGA_HS;
output		     [7:0]		VGA_R;
output		          		VGA_SYNC_N;
output		          		VGA_VS;

//////////// Audio //////////
input 		          		AUD_ADCDAT;
inout 		          		AUD_ADCLRCK;
inout 		          		AUD_BCLK;
output		          		AUD_DACDAT;
inout 		          		AUD_DACLRCK;
output		          		AUD_XCK;

//////////// I2C for EEPROM //////////
output		          		EEP_I2C_SCLK;
inout 		          		EEP_I2C_SDAT;

//////////// I2C for Audio HSMC  //////////
output		          		I2C_SCLK;
inout 		          		I2C_SDAT;

//////////// USB 2.0 OTG //////////
output		     [1:0]		OTG_ADDR;
output		          		OTG_CS_N;
output		     [1:0]		OTG_DACK_N;
inout 		    [15:0]		OTG_DATA;
input 		     [1:0]		OTG_DREQ;
inout 		          		OTG_FSPEED;
input 		     [1:0]		OTG_INT;
inout 		          		OTG_LSPEED;
output		          		OTG_RD_N;
output		          		OTG_RST_N;
output		          		OTG_WE_N;

//////////// IR Receiver //////////
input 		          		IRDA_RXD;

//////////// SDRAM //////////
output		    [12:0]		DRAM_ADDR;
output		     [1:0]		DRAM_BA;
output		          		DRAM_CAS_N;
output		          		DRAM_CKE;
output		          		DRAM_CLK;
output		          		DRAM_CS_N;
inout 		    [31:0]		DRAM_DQ;
output		     [3:0]		DRAM_DQM;
output		          		DRAM_RAS_N;
output		          		DRAM_WE_N;

//////////// SRAM //////////
output		    [19:0]		SRAM_ADDR;
output		          		SRAM_CE_N;
inout 		    [15:0]		SRAM_DQ;
output		          		SRAM_LB_N;
output		          		SRAM_OE_N;
output		          		SRAM_UB_N;
output		          		SRAM_WE_N;

//////////// Flash //////////
output		    [22:0]		FL_ADDR;
output		          		FL_CE_N;
inout 		     [7:0]		FL_DQ;
output		          		FL_OE_N;
output		          		FL_RST_N;
input 		          		FL_RY;
output		          		FL_WE_N;
output		          		FL_WP_N;

//////////// GPIO, GPIO connect to GPIO Default //////////
inout 		    [35:0]		GPIO;

//////////// HSMC, HSMC connect to HTG - HSMC to PIO Adaptor //////////
input 		          		HSMC_CLKIN_0;
input 		     [2:1]		HSMC_CLKIN_n;
input 		     [2:1]		HSMC_CLKIN_p;
output		          		HSMC_CLKOUT_0;
output		     [2:1]		HSMC_CLKOUT_n;
output		     [2:1]		HSMC_CLKOUT_p;
inout 		     [3:0]		HSMC_D;
inout 		    [16:0]		HSMC_RX_n;
inout 		    [16:0]		HSMC_RX_p;
inout 		    [16:0]		HSMC_TX_n;
inout 		    [16:0]		HSMC_TX_p;


//=======================================================
//  REG/WIRE declarations
//=======================================================
wire key0, key1, key2, key3;//key0 for system rst or start the system
wire writeclk, readclk;
wire [15:0] data, data_i, data_o;
reg readenable;
reg writeenable;
wire [2:0] state;
wire oe,we,ce;
reg add,minus,enable_add,enable_minus;
reg [3:0] speed;
reg [1:0]x_clkcount;
reg xclk;
//reg [1:0] rw, rw_next;
reg [1:0] rw;
reg [6:0] play_time, record_time;
reg forward;
reg flag;//for key
reg [20:0]clks;//for key
reg [20:0] debug_ptr;
assign AUD_XCK = xclk;
//assign data = ((rw == 2'b11)? 16'bz : data_o);//output for reading else input for writing
//assign data_i = ((rw == 2'b10)? data : 16'bz);
assign SRAM_LB_N = 1'b0;
assign SRAM_UB_N = 1'b0;
assign SRAM_CE_N = ~ce;
assign SRAM_WE_N = ~we;
assign SRAM_OE_N = ~oe;
wire [15:0] delta;
wire finish;
reg [15:0] data_f;
reg slow_clock;
reg [3:0] speed_count;
wire first_order = SW[4];
wire [15:0] data_to_DAC = ((first_order&&slow)? data_f : data_i);
wire readclkk = (slow? slow_clock : readclk);
assign LEDR[17] = first_order;

//=======================================================
//  Structural coding
//=======================================================

I2C 				i2c(.iCLK(CLOCK_50), .iRST_N(1'b1), .I2C_SCLK(I2C_SCLK), .I2C_SDAT(I2C_SDAT));
ADC				adc(writeenable, AUD_BCLK, AUD_ADCLRCK, AUD_ADCDAT, data_o, writeclk);
DAC				dac(readenable, AUD_BCLK, AUD_DACLRCK, AUD_DACDAT, data_to_DAC/*data_i*/, readclk);
key_debounce	k0(KEY[0], CLOCK_50, key0);
key_debounce 	k1(KEY[1], CLOCK_50, key1);
key_debounce	k2(KEY[2], CLOCK_50, key2);
key_debounce 	k3(KEY[3], CLOCK_50, key3);
sram_control_light 	s0(~key0, rw, CLOCK_50, readclkk/*readclk*/, writeclk, forward, speed, slow, data_o, data_i, ce, we, oe, SRAM_ADDR, SRAM_DQ, play_time, record_time, full, debug_ptr);
calculate_delta	cc(delta, first_order, slow_clock, ~key0, data_f, data_i, speed, CLOCK_50, finish);

///////////////// state ///////////////////////////////
always @(*) begin
	if (SW[2]&&(!SW[1])) begin//play
		rw = 2'b11;
		readenable = 1'b1;
		writeenable = 1'b0;
	end
	else if (SW[1]&&(!SW[2])) begin//record
		rw = 2'b10;
		readenable = 1'b0;
		writeenable = 1'b1;
	end
	else begin
		readenable = 1'b0;
		writeenable = 1'b0;
		rw = 2'b00;
	end
end

reg flash; 
assign LEDG[0] = flash;
/////////////////// flash light as record full /////////
always @(*) begin
	if (full)
		flash = clks[20];
	else
		flash = 1'b0;
end

/////////////////// forward and backward////////////////
always @(*) begin
	if		(SW[2]&&!SW[3])		begin	forward=1'b1;	end
	else if	(SW[2]&&SW[3])		begin	forward=1'b0;	end
	else						begin	forward=1'b1;	end
end

///////////// prevent form key initial problem//////////
always @(posedge CLOCK_50) begin
	clks <= clks + 1'b1;
end
always @(*) begin 
	if (clks == 20'd1000)
		flag = 1'b1;
end

//////////////////// speed ///////////////////////////////
reg slow; //0 for fast speed and origin speed, 1 for slow speed
// asjust the speed
always @(posedge CLOCK_50) begin
	if (key0 == 1'b0) begin
		speed <= 1'b0;
		slow <= 1'b0;
	end
	else begin
		if(add != enable_add) begin
			if((speed < 4'b1000)&&(speed >= 4'b0000)&&(slow == 1'b0))	begin
				speed <= speed + 3'b001;		
			end 
			else if ((speed == 1'b1)&&(slow == 1'b1)) begin
				speed <= speed - 1'b1;
				slow <= 1'b0;
			end
			else if ((speed <= 4'b1000)&&(speed > 4'b0000)&&(slow == 1'b1)) begin
				speed <= speed - 1'b1;
			end
			else	begin	end;
			add<= enable_add;
		end
		else	begin	end
		
		if(minus != enable_minus) begin
			if((speed <= 4'b1000)&&(speed > 4'b0000)&&(slow == 1'b0))	begin
				speed <= speed - 3'b001;		
			end 
			else if (speed == 4'b0000) begin	
				speed <= speed + 1'b1;
				slow <= 1'b1;
			end
			else if ((speed < 4'b1000)&&(speed > 4'b0000)&&(slow == 1'b1)) begin
				speed <= speed + 3'b001;
			end
			else begin end
			minus<= enable_minus;
		end
		else	begin	end
	end
end


//key 1 for speed up , key 0 for slow down
always @(negedge key1) begin // speed up
	if (flag == 1'b1)
		enable_add <= ~enable_add;
end

always @(negedge key2) begin // slow down
	if (flag == 1'b1)
		enable_minus <= ~enable_minus;
end

/////////////////////// play slow speed ////////////////////

always @(posedge readclk) begin
	if (slow && !first_order) begin
		if (speed_count >= speed) begin
			speed_count <= 1'b0;
			slow_clock <= 1'b1;
		end
		else begin
			slow_clock <= 1'b0;
			speed_count <= speed_count + 1'b1;
		end
	end
	if (slow && first_order) begin
		if (speed_count >= speed) begin
			data_f <= data_f + delta;
			speed_count <= 1'b0;
			slow_clock <= 1'b1;
		end
		else if (speed_count == 1'b0) begin
			data_f <= data_i;
			speed_count <= speed_count + 1'b1;
			slow_clock <= 1'b0;
		end
		else begin
			speed_count <= speed_count + 1'b1;
			slow_clock <= 1'b0;
		end
	end
end


/////////////////////////// handle x_clk ////////////////////
always @(posedge CLOCK_50) begin
	if (x_clkcount > 2'b01) begin
		xclk <= ~xclk;
		x_clkcount <= 1'b0;
	end
	else
		x_clkcount <= x_clkcount + 1'b1;
end


///////////////////// for timer ////////////////////////////
reg [6:0] timer;
always @(*) begin
	if (rw == 2'b10)
		timer = record_time;
	else
		timer = play_time;
end



wire [6:0] a, b, c, d, e, f, g, h, i;
DISPLAY_alphabet dis_Alp(a, b, c, d, rw);
assign HEX0 = a;
assign HEX1 = b;
assign HEX2 = c;
assign HEX3 = d;
//wire [6:0] timer = (readenable? record_time : play_time);
DISPLAY_number dis_Sec(e, f, timer);
assign HEX4 = e;
assign HEX5 = f;
wire [3:0] slowfastt = (slow ? 4'b1000 : 4'b1011);
LIGHT_alphabet dis_FS(g, slowfastt);
assign HEX7 = g;
DISPLAY_number dis_Sec2(h, i, {3'b000,speed});
assign HEX6 = h;
//assign GPIO[15:0] = data_o;
assign GPIO[35:15] = debug_ptr;
//assign GPIO[31] = readenable;
//assign GPIO[32] = AUD_ADCLRCK;
//assign GPIO[35:33] = state;
assign GPIO[0] = CLOCK_50;
assign GPIO[1] = AUD_BCLK;
endmodule
